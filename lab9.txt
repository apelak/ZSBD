
CREATE OR REPLACE PACKAGE PKG_LAB_ZADANIA AS
    PROCEDURE add_job(p_job_id IN jobs.job_id%TYPE, p_job_title IN jobs.job_title%TYPE);
    PROCEDURE update_job_title(p_job_id IN jobs.job_id%TYPE, p_new_title IN jobs.job_title%TYPE);
    PROCEDURE delete_job(p_job_id IN jobs.job_id%TYPE);
    PROCEDURE get_emp_salary(p_emp_id IN employees.employee_id%TYPE, p_salary OUT employees.salary%TYPE, p_lastname OUT employees.last_name%TYPE);
    PROCEDURE add_employee_custom(p_lastname IN employees.last_name%TYPE, p_email IN employees.email%TYPE, p_job_id IN employees.job_id%TYPE, p_salary IN employees.salary%TYPE);
    PROCEDURE get_manager_avg_salary(p_manager_id IN employees.manager_id%TYPE, p_avg_salary OUT NUMBER);
    PROCEDURE raise_salary_dept(p_dept_id IN departments.department_id%TYPE, p_percent IN NUMBER);
    PROCEDURE transfer_employee(p_emp_id IN employees.employee_id%TYPE, p_new_dept_id IN departments.department_id%TYPE);
    PROCEDURE delete_dept_if_empty(p_dept_id IN departments.department_id%TYPE);

    FUNCTION get_job_name(p_job_id jobs.job_id%TYPE) RETURN VARCHAR2;
    FUNCTION get_yearly_income(p_emp_id employees.employee_id%TYPE) RETURN NUMBER;
    FUNCTION format_phone(p_phone VARCHAR2) RETURN VARCHAR2;
    FUNCTION capitalize_ends(p_text VARCHAR2) RETURN VARCHAR2;
    FUNCTION pesel_to_date(p_pesel VARCHAR2) RETURN DATE;
    FUNCTION get_country_stats(p_country_name countries.country_name%TYPE) RETURN VARCHAR2;
    FUNCTION gen_access_id(p_first_name VARCHAR2, p_last_name VARCHAR2, p_phone VARCHAR2) RETURN VARCHAR2;
END PKG_LAB_ZADANIA;

CREATE OR REPLACE PACKAGE PKG_REGIONS_MGMT AS
    e_name_exists EXCEPTION;
    e_has_countries EXCEPTION;
    PRAGMA EXCEPTION_INIT(e_has_countries, -2292); -- Powiązanie z błędem klucza obcego ORA-02292

    PROCEDURE log_error(p_proc VARCHAR2, p_code NUMBER, p_msg VARCHAR2);
    PROCEDURE create_region(p_id NUMBER, p_name VARCHAR2);
    FUNCTION read_region(p_id NUMBER) RETURN VARCHAR2;
    FUNCTION read_region(p_name VARCHAR2) RETURN NUMBER;
    PROCEDURE delete_region(p_id NUMBER);
END PKG_REGIONS_MGMT;

CREATE OR REPLACE PACKAGE BODY PKG_REGIONS_MGMT AS
    PROCEDURE log_error(p_proc VARCHAR2, p_code NUMBER, p_msg VARCHAR2) IS
    BEGIN
        INSERT INTO ERROR_AUDIT_LOG (proc_name, error_code, error_msg)
        VALUES (p_proc, p_code, p_msg);
        COMMIT;
    END;

    PROCEDURE create_region(p_id NUMBER, p_name VARCHAR2) IS
        v_count NUMBER;
    BEGIN
        SELECT COUNT(*) INTO v_count FROM regions WHERE LOWER(region_name) = LOWER(p_name);
        IF v_count > 0 THEN RAISE e_name_exists; END IF;
        INSERT INTO regions (region_id, region_name) VALUES (p_id, p_name);
    EXCEPTION
        WHEN e_name_exists THEN
            log_error('create_region', -20010, 'Region o nazwie ' || p_name || ' już istnieje.');
            RAISE_APPLICATION_ERROR(-20010, 'Nazwa regionu musi być unikalna.');
    END;

    FUNCTION read_region(p_id NUMBER) RETURN VARCHAR2 IS
        v_name regions.region_name%TYPE;
    BEGIN
        SELECT region_name INTO v_name FROM regions WHERE region_id = p_id;
        RETURN v_name;
    END;

    FUNCTION read_region(p_name VARCHAR2) RETURN NUMBER IS
        v_id regions.region_id%TYPE;
    BEGIN
        SELECT region_id INTO v_id FROM regions WHERE LOWER(region_name) = LOWER(p_name);
        RETURN v_id;
    END;

    PROCEDURE delete_region(p_id NUMBER) IS
    BEGIN
        DELETE FROM regions WHERE region_id = p_id;
    EXCEPTION
        WHEN e_has_countries THEN
            log_error('delete_region', -2292, 'Nie można usunąć regionu ' || p_id || ' - istnieją kraje.');
            RAISE_APPLICATION_ERROR(-20011, 'Nie można usunąć regionu, który posiada przypisane kraje.');
    END;
END PKG_REGIONS_MGMT;

CREATE OR REPLACE PACKAGE PKG_DEPT_STATS AS
    FUNCTION get_avg_salary(p_dept_id NUMBER) RETURN NUMBER;
    PROCEDURE get_job_salary_range(p_job_id VARCHAR2, p_min OUT NUMBER, p_max OUT NUMBER);
    PROCEDURE generate_dept_report(p_dept_id NUMBER);
END PKG_DEPT_STATS;

CREATE OR REPLACE PACKAGE BODY PKG_DEPT_STATS AS
    FUNCTION get_avg_salary(p_dept_id NUMBER) RETURN NUMBER IS
        v_avg NUMBER;
    BEGIN
        SELECT AVG(salary) INTO v_avg FROM employees WHERE department_id = p_dept_id;
        RETURN ROUND(NVL(v_avg, 0), 2);
    END;

    PROCEDURE get_job_salary_range(p_job_id VARCHAR2, p_min OUT NUMBER, p_max OUT NUMBER) IS
    BEGIN
        SELECT min_salary, max_salary INTO p_min, p_max FROM jobs WHERE job_id = p_job_id;
    END;

    PROCEDURE generate_dept_report(p_dept_id NUMBER) IS
        v_dept_name departments.department_name%TYPE;
    BEGIN
        SELECT department_name INTO v_dept_name FROM departments WHERE department_id = p_dept_id;
        DBMS_OUTPUT.PUT_LINE('--- RAPORT DLA DEPARTAMENTU: ' || v_dept_name || ' ---');
        DBMS_OUTPUT.PUT_LINE('Średnia pensja: ' || get_avg_salary(p_dept_id));
        DBMS_OUTPUT.PUT_LINE('-------------------------------------------');
    EXCEPTION
        WHEN NO_DATA_FOUND THEN DBMS_OUTPUT.PUT_LINE('Błąd: Departament nie istnieje.');
    END;
END PKG_DEPT_STATS;

CREATE OR REPLACE PACKAGE PKG_DATA_AUTO AS
    PROCEDURE auto_fix_phones;
    PROCEDURE mass_salary_update(p_job_id_part VARCHAR2, p_percent NUMBER);
END PKG_DATA_AUTO;

CREATE OR REPLACE PACKAGE BODY PKG_DATA_AUTO AS
    PROCEDURE auto_fix_phones IS
    BEGIN
        UPDATE employees 
        SET phone_number = '(' || SUBSTR(phone_number, 1, 3) || ') ' || SUBSTR(phone_number, 5)
        WHERE phone_number NOT LIKE '(%)%';
        DBMS_OUTPUT.PUT_LINE('Zaktualizowano formaty telefonów dla ' || SQL%ROWCOUNT || ' wierszy.');
    END;

    PROCEDURE mass_salary_update(p_job_id_part VARCHAR2, p_percent NUMBER) IS
    BEGIN
        FOR r IN (SELECT employee_id, salary, job_id FROM employees WHERE job_id LIKE '%' || p_job_id_part || '%') LOOP
            DECLARE
                v_min NUMBER; v_max NUMBER; v_new NUMBER;
            BEGIN
                SELECT min_salary, max_salary INTO v_min, v_max FROM jobs WHERE job_id = r.job_id;
                v_new := r.salary * (1 + p_percent/100);
                
                IF v_new BETWEEN v_min AND v_max THEN
                    UPDATE employees SET salary = v_new WHERE employee_id = r.employee_id;
                END IF;
            END;
        END LOOP;
        COMMIT;
    END;
END PKG_DATA_AUTO;

